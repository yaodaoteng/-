

 **选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法**

## 快排  平均时间复杂度也是：O(nlogn) 最差的情况下时间复杂度为：O( n^2 )

- 从数列中挑出一个元素，称为 “基准”（pivot）;
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
- 用一个指向左边的游标 i，和指向右边的游标 j，逐渐移动这两个游标，直到找到 arr[i] > pivot 和 arr[j] < pivot, 停止移动游标，交换 arr[i] 和 arr[j]，交换完后 i++，j--（对下一个元素进行比较），直到 i>=j，停止移动。

```cpp
vvoid swap(int *arr, int i, int j){
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

int partition(int *arr,int startIndex,int endIndex){
    int pivot = arr[startIndex]; //取第一个元素为基准值
    int l = startIndex,h = endIndex ;
    while(true){
        //从左向右扫描
        while(arr[++l]<pivot && l!=endIndex);
        //从右往左扫描
        while(arr[--h]>pivot && h!=startIndex);
        //左右指针相遇
        if(l>=h)
            break;
        //交换左右数据
        swap(arr,l,h);//最后肯定是hi下标指向小于p的最后一个元素
     }
     //将基准值插入序列
     swap(arr,startIndex,h);
     return h;
}

void quicksort(int *arr,int start,int end){
    if(start == end)
        return;
    if(arr == NULL)
        return ;
    //切分
    int pivotIndex = partition(arr,start,end);
   for (int it = 0; it < 10; it++)
        cout << arr[it] << " ";
    cout << endl;
    if(pivotIndex-1>=start)
        quicksort(arr,start,pivotIndex - 1);
    if(pivotIndex + 1 <end)
        quicksort(arr,pivotIndex + 1,end);
}
 
```



## 归并排序  时间复杂度是o(nlogn).

归并排序，采用分治思想，先把待排序序列拆分成一个个子序列，直到子序列只有一个元素，停止拆分，然后对每个子序列进行边排序边合并。其实，从名字「归并」可以看出一丝「拆、合」的意思（妄加猜测）。

```c++
 void merge(int *arr, int start, int mid, int end){
  
    //start为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素
  int size = end - start + 1;
  int *temp = new int[size];
  int i = start, j = mid + 1, k = 0; //mid + 1为第2有序区间的第一个元素

  while(i <= mid && j <= end){
    if(arr[i] <= arr[j])
      temp[k++] = arr[i++];
    else
      temp[k++] = arr[j++];
  }
  while(i <= mid) // 若比较晚之后，第一个有序区间还有剩余，则直接复制到数组中
    temp[k++] = arr[i++];

  while(j <= end) //同上
    temp[k++] = arr[j++];
  //将排好序的存回arr中的start到end区间
  for (i = start, k = 0; i <= end; i++, k++)
    arr[i] = temp[k];

  delete[] temp;

} 

void mergesort(int *arr, int startIndex, int endIndex){
  if(startIndex == endIndex)
    return;
  if(arr == NULL)
    return;
  //中部下标
  int midIndex = startIndex + (endIndex - startIndex) / 2;

  if(midIndex > startIndex)
    mergesort(arr, startIndex, midIndex);
  if(midIndex + 1 < endIndex)
    mergesort(arr, midIndex + 1, endIndex);

  //归并
  merge(arr, startIndex, midIndex, endIndex);
}
```





## 堆排序

- 创建一个堆 H[0……n-1]；
- 把堆首（最大值）和堆尾互换；
- 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
- 重复步骤 2，直到堆的尺寸为 1。

```cpp
void down(vector<int> & vec, int start, int end) {
    int pos = start;
    int child = 2*pos+1;
    while (child <= end) {//确定要交换的孩子节点的下标
      if (child+1 <=end && vec[child] > vec[child+1]) {
        child++;
      }

      if (vec[child] < vec[pos]) {//如果最小的孩子节点都小于该节点时，则交换位置
        swap(vec[child],vec[pos]);
      }
      else {
        break;//说明无需调整
      }
      pos = child;
      child = 2 * pos + 1;
    }
}
  
void make_heap(vector<int> & vec) {
    int len = vec.size();
    for (int i = len / 2 - 1; i >= 0; i--) {//对前N/2个元素进行下沉操作即可构建堆
      down(vec, i, len-1);
    }
}

void sort_heap(vector<int> & vec) {
    make_heap(vec);
    int end = vec.size()-1;
    for (int i = 0; i < vec.size(); i++) {
      swap(vec[0],vec[end]);//将首元素和堆中最后一个元素互换
      down(vec,0,--end);//然后将首部元素下沉即可
    }
}
```



## 计数排序  适用于待排序序列中元素的取值范围比较小。

- 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max
- 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)
- 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数
- 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数

稳定性：在元素往 countArr 中记录时按顺序遍历，从 countArr 中取出元素也是按顺序取出，相同元素相对位置不会发生变化，故稳定。

空间复杂度：需要额外申请空间，复杂度为“桶”的个数，故为 O ( k )， k 为“桶”的个数，也就是 countArr 的长度;

时间复杂度：最好最坏都为 O(n+k)， k 为“桶”的个数，也就是 countArr 的长度



## 插入排序

- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

  

  稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序；
  空间复杂度：它是在原序列进行排序，故为 O ( 1 );

  时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n * n );

## 选择排序

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。

稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。

空间复杂度：在原序列进行操作，故为 O( 1 );

 时间复杂度：需要 2 次循环遍历，故为 O( n * n );