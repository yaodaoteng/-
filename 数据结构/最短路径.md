a1003

作为一个城市的紧急救援队队长，你得到了一张你国家的特别地图。地图显示了几个分散的城市，由一些道路连接。地图上标明了每个城市救援队的数量以及每对城市之间的每条道路的长度。当有来自其他城市的紧急电话给你时，你的工作是带领你的人尽快到达这个地方，同时，在路上召集尽可能多的人。

输入规格： 每个输入文件包含一个测试用例。对于每个测试用例，第一行包含 4 个正整数：N (≤500) - 城市数量（城市编号从 0 到 N−1），M - 道路数量，C 1 C 2 -分别是您当前所在和必须保存的城市。下一行包含 N 个整数，其中第 i 个整数是第 i 个城市的救援队数量。然后是M行，每行用三个整数c 1 ，c 2 和L描述一条道路，分别是道路连接的城市对和道路的长度。保证至少存在一条从 C 1 到 C 2 的路径。 

输出规格： 对于每个测试用例，在一行中打印两个数字：C 1 和 C 2 之间不同的最短路径的数量，以及您可能收集的最大救援队数量。一行中的所有数字必须正好用一个空格隔开，并且行尾不允许有多余的空格。

```in
5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1

2 4
```

思路：以w[u]表示从起点s到达顶点u可以得到的最大点权之和，初始为0；以num[u]表示从起点s到达顶点u的最短路径条数，初始化时只有num[s]为1，其余num[u]均为0、

```c++
/*
 * @Author: yaodaoteng
 * @Date: 2021-05-24 14:10:52
 * @LastEditors: yaodaoteng
 * @LastEditTime: 2021-05-24 14:21:42
 * @FilePath: \vscode\pta1003.cpp
 */
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXV = 510;
const int INF = 1000000000;

int n, m, st, ed, G[MAXV][MAXV], weight[MAXV];
int d[MAXV], w[MAXV], num[MAXV];
bool vis[MAXV] = {false};

void Dijkstra(int s){
    fill(d, d + MAXV, INF);
    memset(num, 0, sizeof(num));
    memset(w, 0,sizeof(w));
    d[s] = 0;
    w[s] = weight[s];
    num[s] = 1;
    for (int i = 0; i < n; i++){
        int u = -1, MIN = INF;
        for (int j = 0; j < n; j++){
            if(vis[j] == false && d[j] < MIN){
                u = j;
                MIN = d[j];
            }
        }
        if(u == -1)
            return;
        vis[u] = true;
        for (int v = 0; v < n; v++){
            if(vis[v] == false && G[u][v] != INF){
                if(d[u] + G[u][v] <d[v]){
                    d[v] = d[u] + G[u][v];
                    w[v] = w[u] + weight[v];
                    num[v] = num[u];
                }else if(d[u] + G[u][v] ==d[v]){
                    if(w[u] + weight[v] > w[v])
                        w[v] = w[u] + weight[v];
                    num[v] += num[u];
                }
            }
        }
    }
}

int main(){
    scanf("%d%d%d%d", &n, &m, &st, &ed);
    for (int i = 0; i < n; i++)
        scanf("%d", &weight[i]);//读入点权
    int u, v;
    fill(G[0], G[0] + MAXV * MAXV, INF);
    for (int i = 0; i < m; i++){
        scanf("%d%d", &u, &v);
        scanf("%d", &G[u][v]);
        G[v][u] = G[u][v];
    }
    Dijkstra(st);
    printf("%d %d\n", num[ed], w[ed]);
    return 0;
}
```



a1018

杭州市有公共自行车服务，为来自世界各地的游客提供了极大的便利。 人们可以在任何车站租一辆自行车，然后将其归还到城市的任何其他车站。 公共自行车管理中心 (PBMC) 持续监控所有站点的实时容量。 如果一个车站正好是半满的，就可以说它处于完美状态。 如果一个车站已满或空，PBMC 将收集或发送自行车以调整该车站的状况以使其完美。 此外，沿途的所有车站也将进行调整。 当报告有问题的站点时，PBMC 将始终选择到达该站点的最短路径。 如果最短路径不止一条，则将选择需要从 PBMC 发送的自行车数量最少的一条。 



输入规格： 每个输入文件包含一个测试用例。对于每种情况，第一行包含 4 个数字： C max (≤100)，始终是偶数，是每个站点的最大容量； N（≤500），总站数； S p ，问题站的索引（站编号从1到N，PBMC用顶点0表示）；和 M，道路的数量。第二行包含 N 个非负数 C i (i=1,⋯,N)，其中每个 C i 分别是当前 S i 处的自行车数量。然后是 M 行，每行包含 3 个数字：S i 、S j 和T ij 描述了T ij 在S i 和S j 之间移动所用的时间。一行中的所有数字都用空格分隔。 

输出规格： 对于每个测试用例，将结果打印在一行中。首先输出 PBMC 必须发送的自行车数量。然后在一个空格后，以如下格式输出路径： 0−>S 1 −>⋯−>S p 。最后在另一个空格之后，输出在S p 的条件调整到完美后我们必须带回PBMC的自行车数量。 请注意，如果这样的路径不是唯一的，则输出需要我们必须带回 PBMC 的最少自行车数量的路径。法官的数据保证这样的路径是唯一的。 

```in
10 3 3 5
6 7 0
0 1 1
0 2 1
0 3 3
1 3 1
2 3 1

3 0->2->3 0
```

思路：为了便于编写代码，把每个点的点权（自行车数目）都减去Cmax/2，这样就可以用点权的正负来直接判断当前车站是需要补给还是需要带走。

每个顶点增加两个属性，从PBMC到当前车站必须携带的自行车数need和到达当前车站是手上多余的数目remain，如果weight[u]为正，说明需要从该车站额外带走，新的remain等于



a1030

a1072

a1087

