## 图的存储



## dfs

[846. 树的重心 - AcWing题库](https://www.acwing.com/problem/content/848/)





## bfs

[847. 图中点的层次 - AcWing题库](https://www.acwing.com/problem/content/849/)





## 最短路径

[849. Dijkstra求最短路 I - AcWing题库](https://www.acwing.com/problem/content/851/)

```c++
int g[N][N];//邻接矩阵
int d[N];//dijkstra的距离,表示从1到n的最短距离,当前的最短距离
bool st[N] = {false};//表示每个点的最短路是否确定
int n,m;

//节点为从1-n
void dijkstra(int s){
    //首先初始化距离,初始化为正无穷
    memset(d,0x3f,sizeof d);
    d[s] = 0;//初始点的距离初始化为0
    
    
    //迭代n次,找最短路
    for(int i = 0; i < n; i++){
        //每一次第一步先找到在每一次还没确定的最短路长度的点当中,距离最小的那一个路径长度
        int u = -1, mind = 0x3f; //-1表示还没有确定
       //遍历所有的点
        for(int j = 1; j <= n; j++){
            //如果当前这个点还没有确定最短路的话
        //并且
        //当前的点还没确定 或者 当前的t不是最短的距离
            if(st[j] == false &&(u == -1 || d[j] < mind)){
                u = j;
                mind = d[j];
            }
        }
        //说明剩下的顶点和起点s 不联通
        if(u == -1) return;
        st[u] = true;
        //用u来更新其他点的距离
        for(int v = 1; v <= n; v++){
             //用s~u的距离加上u~v的这个边,来更新s~v这条边
            if(st[v] == false && g[u][v] != 0x3f)
                d[v] = min(d[v],d[u] + g[u][v]);
        }
    }
}


memset(g,0x3f,sizeof g);//初始化
    
    while(m--){
        int a, b,c;
        cin>>a>>b>>c;
        g[a][b] = min(g[a][b],c);//取min原因是a,b之间可能会有多条边,保留边的最短距离
        
        
    }
    dijkstra(1);//起点为1
    if(d[n] == 0x3f3f3f3f) cout<<-1<<endl;//如果第n个点路径为无穷大即不存在最低路径
    else  cout<<d[n]<<endl;
```





## 最小生成树

[858. Prim算法求最小生成树 - AcWing题库](https://www.acwing.com/problem/content/860/)