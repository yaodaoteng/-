## 图的遍历

### dfs

```CPP
const int MAXV = 1000;//最大顶点数
const int INF = 1000000000;//一个很大的数
//邻接矩阵
int n ,G[MAXV][MAXV];
bool vis[MAXV] = {false};//如果顶点i已被访问，则设为true

void DFS(int u, int depth){//u为当前访问的顶点标号，depth为深度
    vis[u] = true;//设置u已被访问
    //如果对u进行一些操作，可以在这里进行
    //下面对所有能从u出发到达的分支顶点进行枚举
    for(int v = 0; v < n; v++){ //对每个顶点
        if(vis[v] == false && G[u][v] != INF)//如果v未被访问，且u可到达v 
            DFS(v, depth + 1);//访问v，深度+1
    }
    
}

bool DFSTrave(){
    for(int u = 0; u < n; u++){//对每个顶点u
        if(vis[u] == false)
            DFS(u,1);//访问u和u所在的连通块，1表示初始为第一层
    }
}

//邻接表
vector<int> adj[MAXV];//邻接表
int n;//n为顶点数
bool vis[MAXV] = {false};

void DFS(int n, int depth){
    vis[u] = true;
    //如果需要对u进行一些操作，在此处进行
    for(int i = 0; i < adj[u].size(); i++){//对从u出发可以到达的所有顶点v
        int v = adj[u][i];
        if(vis[v] == false)
            DFS(v, depth+1);
    }
}

void DFSTrave(){
    for(int u = 0; u < n; u++){
        if(vis[u] == false)
            DFS(u, 1);
    }
}
```



bfs

```CPP
int n ,G[MAXV][MAXV];
bool inq[MAXV] = {false};//如果顶点i曾入过队，则设为true

void BFS(int u){ //遍历u所在的连通块
    queue<int> q;
    q.push(u);
    inq[u] = true;//设置u已被加入过队列
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int v = 0; v < n; v++){
            //如果u的邻接点v未曾加入过队列
            if(inq[v] == false && G[u][v] != INF){
                q.push(v);
                inq[v] = true;
            }
        }
    }    
}

void BFSTrave(){
    for(int u = 0; u < n; u++){
        if(inq[u] == false)
            BFS(u);
    }
}

//邻接表
vector<int> adj[MAXV];//邻接表
int n;//n为顶点数
bool inq[MAXV] = {false};

void BFS(int u){
    queue<int> q;
    q.push(u);
    inq[u] = true;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(int i = 0; i < adj[u].size(); i++){
            int v = adj[u][i];
            if(inq[v] == false){
                q.push(v);
                inq[v] = t
            }
        }
    }
}

void BFSTrave(){
    for(int u = 0; u < n; u++){
        if(inq[u] == false)
            BFS(u);
    }
}
```



## 最短路径

对任意给出的图G(V,E) 和起点S、终点T，如何求从S到T 的最短路径

### dijkstra算法

解决单源最短路问题：即给定图G和起点s，求得s到达其他每个顶点的最短距离

实现：

集合s用一个bool型数组vis[]实现，激荡vis[i] == true时表示顶点Vi已被访问

令int型数组d[]表示起点s到达顶点Vi的最短距离，出事时除了起点s的d[s]赋为0，其余顶点都赋为一个很大的数字

```
G为图，一般设为全局变量，数组d为源点到达各点的最短路径长度，s为起点
Dijkstra(G,d[],s){
	初始化
	for(循环n次){
		u = 使d[u]最小的还未被访问的顶点的标号
		记u已被访问
		for(从u出发能到达的所有顶点v){
			if(v未被访问 && 以u为中介点使s到顶点v的最短距离d[v]更优)
				优化d[v]
		}
	}
}
```



```cpp
//邻接矩阵
int  n,G[MAXV][MAXV];
int d[MAVX];//起点到达各点的最短路径长度
bool vis[MAVX] = {false};

void Dijkstra(int s){
    fill (d, d+MAVX,INF);
    d[s] = 0; //起点到达自身的距离为0
    for(int i = 0; i < n; i++){
        int u = -1,MIN = INF; //u是d[u] 最小，MIN存放的是最小的d[u]
        for(int j = 0; j < n; j++){//主要到未访问的顶点中d[]最小的
            if(vis[j] == false && d[j] < MIN){
                u = j;
                MIN = d[j];
            }
        }
        //找不到小于INF的d[u]，说明剩下的顶点和起点s 不联通
        if(u == -1) return;
        vis[u] = true;
        for(int v = 0; v < n; v++){
            if(vis[v] == false && G[u][v] != INF && d[u] + G[u][v] <d[v])
                d[v] = d[u] + G[u][v];
        }
    }
}
```



**要求在所有最短路径中选择第二标尺最优的一条路径**

- 给每条边在增加一个边权（比如花费），然后要求在最短路径有多条是要求路径的花费之和最小

令cost [u] [v]表示u->v的花费，并增加一个数组c[] 令从起点s到达顶点u的最少花费为c[u]   初始化是只有c[s] 为0，其余c[u]均为INF

```
void Dijkstra(int s){
    fill (d, d+MAVX,INF);
    d[s] = 0;
    for(int i = 0; i < n; i++){
        int u = -1,MIN = INF;
        for(int j = 0; j < n; j++){
            if(vis[j] == false && d[j] < MIN){
                u = j;
                MIN = d[j];
            }
        }
        //找不到小于INF的d[u]，说明剩下的顶点和起点s 不联通
        if(u == -1) return;
        vis[u] = true;
        for(int v = 0; v < n; v++){
            if(vis[v] == false && G[u][v] != INF){
            	if(d[u] +G[u][v] < d[v]){
            		d[v] = d[u] + G[u][v];
            		c[v] = c[u] + cost[u][v];
            	}else if(d[u] + G[u][v] == d[v] && c[u] + cost[u][v] < c[v]){
            		c[v] = c[u] +cost[u][v];//最短距离相同时看能否是花费更优            		
            	}
            }
                
        }
    }
}
```



- 给每个点增加一个点权（比如每个城市能收集到物资），然后再最短路径有多条时要求路径上的点权之和最大

用weight[u] 表示城市u中的物资数目，并增加一个数组w[]令从起点s到达顶点u可以收集到的最大物资为w[u],初始化时只有w[s]为weight[s].其余w[u] 均为0

```
for(int v = 0; v < n; v++){
            if(vis[v] == false && G[u][v] != INF){
            	if(d[u] +G[u][v] < d[v]){
            		d[v] = d[u] + G[u][v];
            		w[v] = w[u] + weight[v];
            	}else if(d[u] + G[u][v] == d[v] && w[u] + weight[v] > w[v]){
            		w[v] = w[u] + weight[v];//最短距离相同时看能否使w更优            		
            	}
            }
                
        }
```



- 有多少条最短路径

增加一个数组num[]，令从起点s到达顶点u的最短路径条数为num[u],初始化时只有num[s] 为1，其余num[u] 均为0

```
for(int v = 0; v < n; v++){
            if(vis[v] == false && G[u][v] != INF){
            	if(d[u] +G[u][v] < d[v]){
            		d[v] = d[u] + G[u][v];
            		num[v] = num[u];
            	}else if(d[u] + G[u][v] == d[v]){
            		num[v] += num[u];//最短距离相同时累加            		
            	}
            }
                
        }
```



**如果要确定具体的最短路径，可以用int型pre数组存放每个节点的前驱，然后使用DFS**

```
//邻接矩阵
int  n,G[MAXV][MAXV];
int d[MAVX];//起点到达各点的最短路径长度
bool vis[MAVX] = {false};
int pre[MAXV];//pre[v]表示从起点到顶点v的最短路径上的前一个顶点

void Dijkstra(int s){
    fill (d, d+MAVX,INF);
    d[s] = 0; //起点到达自身的距离为0
    for(int i = 0; i < n; i++){
        int u = -1,MIN = INF; //u是d[u] 最小，MIN存放的是最小的d[u]
        for(int j = 0; j < n; j++){//主要到未访问的顶点中d[]最小的
            if(vis[j] == false && d[j] < MIN){
                u = j;
                MIN = d[j];
            }
        }
        //找不到小于INF的d[u]，说明剩下的顶点和起点s 不联通
        if(u == -1) return;
        vis[u] = true;
        for(int v = 0; v < n; v++){
            if(vis[v] == false && G[u][v] != INF && d[u] + G[u][v] <d[v])
                d[v] = d[u] + G[u][v];//优化d[v]
                pre[v] = u;//记录v的前驱顶点是u
        }
    }
}
```

DFS

```
void DFS(int s, int v){ //s为起点编号，v为当前访问的顶点编号
	if(v==s){//如果当前已经到达起点s
		printf("%d\n",s);
		return;
	}
	DFS(s, pre[v]);//递归访问v的前驱顶点pre[v]
	printf("%d\n",v);//从最深处return回来之后，输出每一层的顶点号
}

//一般将起点st设为全局变量
void DFS(int v){
	if(v == st){
		printf("%d\n",s);
		return;
	}
	DFS(pre[v]);
	printf("%d\n",v);
}
```



