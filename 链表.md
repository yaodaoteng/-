## 链表

### 双指针技巧

- 反转链表 206   双指针

    - 迭代法：使用两个指针完成翻转，pre表示前驱节点，cur表示当前，每次循环需要先保存cur的next节点，然后翻转cur和pre，直到cur为nullptr为止

    - 递归法：递归边界：当head为空节点或者为单个节点时，返回head节点

      ​				单次过程：head->next->next = head表示为由head->Next变为head<-Next，然后断开`head->Next`即将head->next赋为nullptr，现在就完成两个节点的反转了即`由head->Next变为head<-Next了`。

      ```c++
      class Solution{
          public:
          //迭代法
          ListNode* reverseList(ListNode* head) {
              if(nullptr==head||nullptr==head->next)return head;
              //pre为前驱节点，cur为当前节点，每次循环我们需要将cur连上pre，直到cur为空，表示反转结束
              ListNode *pre=nullptr,*cur=head;
              while(cur){
                  ListNode *nxt=cur->next;
                  cur->next=pre;
                  pre=cur;
                  cur=nxt;
              }
              return pre;
          }
          
          //解法2：递归法
          ListNode* reverseList_2(ListNode *head){
              //1:递归边界
              if(nullptr==head||nullptr==head->next)return head;
              //2、递归函数式子：一直到链表尾部才开始反转
              ListNode *p=reverseList(head->next);
              //将head->next节点连上它的前驱节点head，同时将head原始方向(->)断开，也就是head->next赋为nullptr
              head->next->next=head;
              head->next=nullptr;
              return p;
          }
      }
      ```

- 翻转链表2    92  

  ​      双指针法，pre先走m-1步到达位置m的前驱节点，pre不动，然后令cur等于pre->next也就是位置m的起始节点（不变），将[m+1,n]这段链表由前至后的插入到位置m的前面，也就是pre的后面。

  ```c++
  //双指针法，pre先走m-1步到达位置m的前驱节点，pre不动，然后令cur等于pre->next也就是位置m的起始节点（不变），将[m+1,n]这段链表由前至后的插入到位置m的前面，也就是pre的后面
      //换句话说：我们每次循环就是将cur的next节点插入到pre的后面，这样插了n-m次后，就完成反转了
      ListNode* reverseBetween(ListNode* head, int m, int n) {
          //设置哑节点的好处：在m=1时，我们也有前驱节点，也可以将cur的next节点依次插入到pre的后面
          ListNode *dummy=new ListNode(-1);
          dummy->next=head;
          ListNode *pre=dummy;
          //找到m的前驱节点
          for(int i=1;i<m;++i)pre=pre->next;
          ListNode *cur=pre->next;
          for(int i=m;i<n;++i){//每次循环将nxt节点插入到pre的后面
              ListNode *nxt=cur->next;
              //cur将nxt节点后面的链表连接起来
              cur->next=nxt->next;
              //将nxt插入到pre后面
              nxt->next=pre->next;
              pre->next=nxt;
          }
          return dummy->next;
  ```

- 分割链表  86  双指针

，before_head链表存放比x小的节点，after_head链表存放比x大于或等于的节点，我们分别用before和after来前面两个链表添加节点，用head来遍历原始链表。当原始链表遍历完成时，我们需要将before_head链表连接上after_head链表，即`before->next=after_head->next;after->next=nullptr;`。

```c++
//双指针法，before链表存放比x小的节点，after存放比x大的节点
    ListNode* partition(ListNode* head, int x) {
        //初始化链表，注意这里的头节点好处是减少条件判断
        ListNode* before_head=new ListNode(0);ListNode* before=before_head;
        ListNode* after_head=new ListNode(0);ListNode* after=after_head;
        
        //用head来遍历原始链表
        while(head!=nullptr)
        {
            if(head->val<x){
                before->next=head;
                before=before->next;
            }
            else{
                after->next=head;
                after=after->next;
            }
            head=head->next;
        }
        after->next=nullptr;
        before->next=after_head->next;
        return before_head->next;
    }
```



- 环形链表  141  `快慢指针`

  若存在环最终快慢指针会相遇；若不存在环，那么快指针一定会先走到链表尾部。

```c++
 //题解：快慢指针法，若存在环最终快慢指针会相遇；若不存在环，那么快指针一定会先走到链表尾部
    bool hasCycle(ListNode *head) {
        //排除空节点或单个节点不成环的情况
        if(!head||!head->next)return false;
        ListNode *slow=head,*fast=head->next;
        while(slow!=fast)
        {
            //没有环，fast走到链表尾部，fast为空或者fast的next节点为空
            if(!fast||!fast->next)return false;
            slow=slow->next;
            //fast->next->next节点存在，fast才能移动，否则就走到链表尾部了，返回false
            if(fast->next&&fast->next->next)fast=fast->next->next;
            else return false;
        }
        return true;
    }
```

	- 环形链表2   142 `快慢指针`

双指针法：快慢指针，先判断是否有环，若有环则快慢指针相遇，那么此时我们需要将fast还原至链表头部，slow不变，然后二者每次走一步，最终二者的位置就是换的入口；若没有环，我们直接返回nullptr即可。

```c++
//题解2：快慢指针，先判断是否有环，若有环则快慢指针相遇，那么此时我们需要将fast还原至链表头部，slow不变，然后二者每次走一步，最终二者的位置就是换的入口；若没有环，我们直接返回nullptr即可。关于数学公式的证明，大家看官方题解即可。
    ListNode *detectCycle(ListNode *head) {
        //1、排除空节点或单个节点不成环的情况
        if(!head||!head->next)return nullptr;
        ListNode * slow=head->next,*fast=head->next->next;

        //2、以下代码和141一样，判断是否存在环
        while(fast!=slow)
        {
            //没有环，fast走到链表尾部，fast为空或者fast的next节点为空
            if(!fast||!fast->next)return nullptr;
            slow=slow->next;
            fast=fast->next->next;
        }

        //3、找到相遇点了，将fast重置为head，slow不变，然后fast和slow现在开始每次只走一步，相遇点就是环的入口
        fast=head;
        while(fast!=slow)
        {
            fast=fast->next;
            slow=slow->next;
        }
        return slow;
    }
```

- 相交链表  

`快慢指针法`，具体思路更抽象的说就是将链表AB分别变成了A->B和B->A（这里假设A更短一点），这里我们用ha遍历A->B，hb遍历B->A，然后ha指针先走到A-B的B部分，hb指针还在走在B-A的B部分，当hb走到B-A的A部分时，最终二者会相遇，而相遇部分就是公共部分。

```c++
//题解：设链表A的长度为a+c，链表B的长度为b+c，a为链表A不公共部分，b为链表B不公共部分，c为链表A、B的公共部分
    //将两个链表连起来，A->B和B->A，长度：a+c+b+c=b+c+a+c，若链表AB相交，则a+c+b与b+c+a就会抵消，它们就会在c处相遇；若不相交，则c为nullptr，则a+b=b+a，它们各自移动到尾部循环结束，即返回nullptr
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA||!headB)return nullptr;
        ListNode *ha=headA,*hb=headB;
        while(ha!=hb){
            //当ha或hb为空时，它们开始指向另一链表的头部，每次判断ha或hb是否为空进行赋值的好处是当链表AB没有公共部分时ha和hb同时为空，这样避免了死循环
            ha=ha?ha->next:headB;
            hb=hb?hb->next:headA;
        }
        return ha;
    }    
```

- 删除链表的倒数第N个节点  19

`快慢指针法`，起始快指针走n步后，若此时快指针已为空，表示我们删除第一个节点，直接返回head->next即可；否则此时快慢指针一起走，也就是慢指针走size-n步到达倒数第N个节点的前驱节点，快指针会到达链表的尾节点，此时我们删除slow->next节点即可。

```c++
//题解2：快慢指针法，与题解1一样的，不过是使用了快指针计算了链表长度，起始快指针走n步，然后快慢指针一起走size-n步，slow到达前驱节点，fast到达链表尾部
    ListNode* removeNthFromEnd(ListNode* head,int n){
        if(!head)return nullptr;
        ListNode *slow=head,*fast=head;
        while(n--){
            fast=fast->next;
        }
        //n等于size，也就是要删除第一个节点，直接返回head->next
        if(!fast)return head->next;
        while(fast->next){
            slow=slow->next;
            fast=fast->next;
        }
        ListNode *del=slow->next;
        slow->next=del->next;
        delete del;
        return head;
    }
```

- # 有序链表转换二叉搜索树   109

快慢指针法,用两个指针，一块一慢，快的每次走两步，慢的每次走一步，这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的节点的值作为二叉搜索树根节点的值。因为二叉搜索树对应的就是一个有序数组，根节点对应的元素值为为有序数组最中间的位置。

```c++
TreeNode* sortedListToBST(ListNode* head) {
        if(head==nullptr)return nullptr;
        if(head->next==nullptr)return new TreeNode(head->val);
        //设置快慢指针用来找到链表的中点，当fast指针走到尾时，slow指针指向链表中点，pre为slow中点的前一个节点
        ListNode *pre=head,*slow=head->next,*fast=head->next->next;
        while(fast!=nullptr&&fast->next!=nullptr)
        {
            pre=pre->next;
            slow=slow->next;
            fast=fast->next->next;
        }
        //将中点左边的链表断开
        pre->next=nullptr;
        TreeNode* root=new TreeNode(slow->val);//二叉搜索的根节点为数组最中间的数
        root->left=sortedListToBST(head);//根节点的左子树连接链表的前半部分
        root->right=sortedListToBST(slow->next);//根节点的右子树连接链表的后半部分
        return root;
    }
```

- 重排链表 143  首尾指针

首先将原始链表的每一个节点存放在一个数组中，然后我们取首尾指针向中间遍历，每次循环我们需要将左指针的节点连上右指针的节点，在节点连上之后，我们需要将右指针连上未排序的首节点。

```c++
void reorderList(ListNode* head) {
        if(!head)return;
        vector<ListNode*> record;
        while(head){
            record.push_back(head);
            head=head->next;
        }
        int left=0,right=record.size()-1;
        while(left<right){
            //首尾组合连接
            record[left]->next=record[right];
            ++left;
            if(left==right)break;//表示有偶数个节点，重排后相遇了，需要退出
            //尾节点需要连接下次首尾组合的首节点
            record[right]->next=record[left];
            right--;
        }
        //置尾后节点为空
        record[left]->next=nullptr;
    }
```



### 排序

对链表进行插入排序

`插入排序`，我们每次用head->next来进行插入排序，每次插入排序，我们需要从链表的头部开始寻找插入点，所以我们使用一个指针pre来寻找插入点，若pre->next的节点值大于等于head->next的节点时，我们的插入位置就是pre->next，这里处理起来可能麻烦点

```c++
ListNode* insertionSortList(ListNode* head) {
        //dummy用来设置哑节点，pre每次从表头开始进行插入排序
        ListNode* dummy=new ListNode(0),*pre;
        dummy->next=head;

        while(head&&head->next)//注意：我们每次是将head的next节点进行插入排序的
        {
            if(head->val<=head->next->val){//head的next节点值大于等于head的节点值，表示此次不需要进行插入排序，进行下一次循环
                head=head->next;
                continue;
            }
            pre=dummy;
            //寻找插入的位置，pre的next节点值大于等于head的next节点值时，那么pre的next节点就是我们的插入位置
            while(pre->next->val<head->next->val)pre=pre->next;

            //将head的next节点插入到pre的next上
            ListNode *cur=head->next;
            head->next=cur->next;//head连接cur节点后面的链表部分
            cur->next=pre->next;//cur连接pre的next节点，这样链表的顺序已经排好了，且链表还是完整的
            pre->next=cur;
        } 

        return dummy->next;
    }
```

- 排序链表 148

`归并排序`，先2个2个的 merge，完成一趟后，再 4个4个的 merge，直到结束。 时间复杂度(nlogn)

```c++
ListNode* sortList(ListNode* head) {
        ListNode dummy(0);
        dummy.next=head;
        ListNode* p=head;
        int length=0;
        while(p){
            length++;
            p=p->next;
        }
        for(int size=1;size<length;size<<=1)
        {
            ListNode* cur=dummy.next;//每次归并cur都从head节点开始
            ListNode* tail=&dummy;//tail主要用于连接每次归并后的链表
            while(cur){
                ListNode* left=cur;
                ListNode* right=cut(left,size);//将left切断，这样left有size个节点了，此时的right为后半部分的链表头
                cur=cut(right,size);//将right切断，这样right有size个节点了，此时的cur为后半部分的链表头

                tail->next=merge(left,right);//合并right和left
                while(tail->next){//保持tail为尾节点
                    tail=tail->next;
                }
            }
        }
        return dummy.next;
    }

    ListNode* cut(ListNode* head,int n)//将链表head的前n个节点切下来，然后返回后半部分的链表头
    {
        ListNode* p=head;
        while(--n&&p){
            p=p->next;
        }
        if(!p)return nullptr;
        ListNode* next=p->next;
        p->next=nullptr;
        return next;
    }

    ListNode* merge(ListNode* l1,ListNode* l2)//合并两个有序链表
    {
        ListNode dummy(0);
        ListNode* p=&dummy;
        while(l1&&l2){
            if(l1->val<l2->val){
                p->next=l1;
                p=l1;
                l1=l1->next;
            }
            else{
                p->next=l2;
                p=l2;
                l2=l2->next;
            }
        }
        p->next=l1?l1:l2;
        return dummy.next;
    }
```

### 其他

- **K个一组翻转链表 25**

`分治法`，将链表按长度k进行分组，然后每次翻转长度k的链表，注意翻转了长度k的链表后新链表的尾部还要连接未翻转部分。将`[a.b)`范围内k个节点的链表翻转，然后a节点就是翻转后链表的尾节点需要链接剩下的链表节点`[b,tail)`，注意对于区间范围不足k个节点的，不需要进行翻转。

```c++
ListNode* reverseKGroup(ListNode* head, int k) {
        if(head==nullptr)return head;
        ListNode *a=head,*b=head;
        for(int i=0;i<k;++i){
            if(b==nullptr)return head;//[a,b)区间内不足k个元素，不用翻转直接返回head
            b=b->next;
        }
        //newHead表示新链表的头节点
        ListNode *newHead=reverse(a,b);
        //a为翻转后链表的尾节点，需要连接剩下需要翻转的链表
        a->next=reverseKGroup(b,k);
        return newHead;
    }

    //翻转[a,b)区间范围内的链表
    ListNode* reverse(ListNode* a,ListNode* b)
    {
        ListNode *pre=nullptr,*cur=a,*nxt=a;
        while(cur!=b){
            nxt=cur->next;
            cur->next=pre;
            pre=cur;
            cur=nxt;
        }
        return pre;
    }
```

- 旋转链表 61 

先求出链表长度size，若k取余size为空，那么不用旋转了，直接返回head；否则将链表首尾相连形成环形链表，由于k表示尾节点移动k%size位，那么头节点移动size-k%size位。

```c++
ListNode* rotateRight(ListNode* head, int k) {
        if(!head||k==0)return head;
        ListNode *tail=head;
        int size=1;
        while(tail->next){
            size++;
            tail=tail->next;
        }
        if(k%size==0)return head;
        //首尾相连，形成环形链表
        tail->next=head;
        int m=size-k%size;
        //tail移动m步，到达新头节点的前驱节点
        while(m--)tail=tail->next;
        //tail的next节点为新的头节点，顺便断开环形链表
        ListNode *res=tail->next;
        tail->next=nullptr;
        return res;
    }
```

- 删除排序链表中的重复元素2   82

遍历链表，若head的节点值与head的next节点值不相等，则pre指向head，也就是不重复节点；若相等，我们需要找到重复值子链表的最后一个节点，然后令pre指向head->next，同时head移动到下一个节点。

```c++
//思路：遍历链表，pre用来指向不重复节点
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head->next)return head;
        ListNode *dummy=new ListNode(-1);
        dummy->next=head;
        ListNode *pre=dummy;
        while(head&&head->next){
            if(head->val!=head->next->val){//head与head->next节点值不相等，pre指向head，也就是指向不重复值
                pre=head;
                head=head->next;
            }
            else{
                //head为重复值子链表的最后一个节点，比如1->1->1->2的最后一个1
                while(head&&head->next&&head->val==head->next->val){
                    head=head->next;
                }
                //pre连接重复值子链表的之后第一个节点
                pre->next=head->next;
                head=head->next;
            }
        }
        return dummy->next;
    }
```

- 分割链表  725

，首先求出链表的长度，然后根据k来求得每段链表的平均长度，顺便求出余数。由于题目要求每部分长度相差不能超过1，而且排在前面的部分长度要大于后面部分的长度，所以我们根据余数的个数，给排在前面的部分长度+1。

```c++
//思路：先求出链表的长度，然后求出链表的平均长度，以及余数。由于题目规定任意两部分的长度不能超过1，所以余数依次给排在前面的平均长度+1即可
    vector<ListNode*> splitListToParts(ListNode* root, int k) {
        int size=0;
        ListNode *p=root;
        while(p){
            size++;
            p=p->next;
        }
        int avg_size=size/k,mod=size%k;
        vector<ListNode*> res(k,nullptr);
        ListNode *cur=root,*pre=nullptr;
        for(int i=0;i<k;++i)
        {
            res[i]=cur;
            //mod为0时，即使平均长度为0，cur为nullpre，不能实现断链了，即添加为nullptr
            int temp_size=mod?(avg_size+1):avg_size;
            while(temp_size--){
                pre=cur;
                cur=cur->next;
            }
            //pre为cur的前驱节点，也就是当前长度的最后一个节点，作用是实现断链
            if(pre)pre->next=nullptr;
            if(mod)mod--;
        }
        return res;
    }
```

