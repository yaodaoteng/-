**滑动窗口思想：**

①）窗口由两个指针构成，一个左指针`left`，一个右指针`right`，然后`[left,right]`表示的索引范围是一个窗口了。

②）右指针`right`的功能是用来扩展窗口：当窗口内的条件没有达到题目要求时，我们需要不断移动右指针`right`直到窗口内的条件第一次满足题目要求为止。

③）左指针`left`的功能是用来缩小窗口的：当窗口内的条件已满足题目条件或多于题目条件时（窗口溢出），我们缩小窗口，也就是左指针`left`需要右移直到窗口条件不满足为止。这时，我们需要记录当前窗口的大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针`right`，使得窗口满足题目的条件。

注：滑动窗口用来**处理连续满足一定条件的连续区间的性质（长度等）问题的**，两个指针都起始于原点，并一前一后向终点前进。



- 3 无重复字符的最长子串

用set用来当窗口，用来存放遍历到的字符，若没有遇到重复字符，right继续扩展，同时更新max；若遇到重复字符，我们需要缩小窗口，也就是left右移

```c++
//滑动窗口，用set来存放窗口值
    int lengthOfLongestSubstring(string& s) {
        set<char> window;        //窗口,set不允许重复关键字，自动去重
        
        int left=0,right=0;     //窗口边界
        int result=0,n=s.size();
        
        while(right<n)
        {
            if(window.find(s[right])==window.end())//没有出现重复字符，继续扩大窗口
            {
                window.insert(s[right++]);
                result=max(result,(int)window.size());
            }
            else//出现重复字符，缩小窗口
            {
                window.erase(s[left++]);
            }
        }
        return result;
    }
```

- 76 最小覆盖子串

用两个hashmap（`window`,`needs`）来建立字符表，其中needs用来建立存放模式串t的字符表，window用来存放总串s中用来和needs匹配字符的字符表。当窗口的字符个数满足needs时，我们需要更新子串的长度以及子串的起始位置，然后就是缩小窗口了。

```c++
string minWindow_1(string s, string t) {
        //最小字串的开始位置和最小长度
        int start=0,minLength=INT_MAX;
        
        unordered_map<char,int> needs;
        unordered_map<char,int> window;
        
        //建立字符串t的字符表
        for(char c:t)needs[c]++;
        
        //初始化窗口区间和记录窗口中满足的字符个数
        int left=0,right=0,match=0;
        
        //开始滑动窗口
        while(right<s.size())
        {
            char c1=s[right];
            if(needs.count(c1)){//字符c1存在于t的字符表中
                window[c1]++;//加入window
                if(window[c1]==needs[c1])//字符c1的个数已经满足字符表中的个数了
                    match++;
            }
            right++;
            
            while(match==needs.size())
            {
                if(right-left<minLength){//窗口的大小小于最小长度，更新字符串
                    start=left;
                    minLength=right-left;
                }
                char c2=s[left];
                if(needs.count(c2)){//c2在needs中，主要用来去除window中多余的字符数的
                    window[c2]--;//字符c2的个数减1
                    if(window[c2]<needs[c2])//字符c2出现次数不再符合要求
                        match--;
                }
                left++;//不管c2在不在needs中，都需要将left右移，因为此时的window的字符个数必然多于needs的字符个数
            }
        }
        
        return minLength==INT_MAX?"":s.substr(start,minLength);
    }
    
    string minWindow_2(string s, string t){
        //t不是s的字串
        if(s.size()<t.size())return "";
        
        //建立t的字符表
        int count[256] = {0};
        for(char c:t)count[c]++;
        
        int left=0,right=0;//窗口的左右指针
        int len=0,minLen=s.size();//len表示当前窗口匹配t中的字符个数
        string result;
        
        int n=s.size();
        for(;right<n;++right){
            if(count[s[right]]>0)//右指针指向s中的字符存在于count中
                len++;
            count[s[right]]--;//该字符的个数减1，表示s与t匹配了一个字符或者没有匹配到字符，该字符的个数可能为负数
            
            while(len==t.size())//s中的字符串已经满足t的字符串了
            {
                if(right-left+1<=minLen){//窗口大小小于最小子串，更新最小子串
                    minLen=right-left+1;
                    result=s.substr(left,right-left+1);
                }
                count[s[left]]++;//移动窗口的左指针
                
                if(count[s[left]]>0)len--;//字符的个数不在符合条件，表示window移动多了，正常匹配的话，count的每个字符为0
                
                left++;
            }
        }
        return result;
    }
```

- 239 滑动窗口的最大值

第一种解法就是暴力法求解，当窗口的大小等于k时，我们需要将该窗口内的最大值添加到result中，同时右移左指针left将窗口缩小；当窗口的大小小于k时，我们进行滑动right就行了。left、right分别表示窗口的左右边界，当窗口的大小为k（`right-left+1=k`）时，用`max_element()`求出窗口内的最大值添加到result即可，然后遍历数组，直到`right=nums.size()`时遍历结束，返回result

第二种解法使用双向队列作为窗口，来保存数组的下标，并保持窗口头部的下标表示的元素为该窗口的最大值。duque用来存放窗口window的下标，并保持窗口头部的下标表示的元素为该窗口的最大值。当添加新元素时，新元素与`窗口尾部下标表示的元素window.back()`相比较，若新元素大于`窗口尾部下标表示的元素window.back()`，则直接把尾部下标弹出队列`window.pop_back()`直至新元素小于`尾部下标表示的元素window.back()`或窗口为空为止。还有一点需要注意的是：当窗口头部的下标小于等于i-k时，需要将头部下标弹出队列`window.pop_front()`，因为此时窗口中的队头下标属于上一个窗口的，需要删除。

```c++
//解法1：暴力法+滑动窗口
    vector<int> maxSlidingWindow_1(vector<int>& nums, int k) {
        vector<int> result;
        int left=0,right=0,n=nums.size();
        
        while(right<n)
        {
            if(right-left+1==k)//达到窗口k
            {
                auto it=max_element(nums.begin()+left,nums.begin()+right+1);//求出窗口的最大值
                result.push_back(*it);
                left++;
            }
            right++;
        }
        return result;
    }
    
    //解法2：双向队列+滑动窗口
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if(nums.empty()||k==0)return {};
        vector<int> result;
        deque<int> window;//窗口，窗口保存数组的下标
        
        for(int i=0;i<k;++i)
        {
            //窗口不为空并且下标i表示的元素大于window尾部下标表示的元素，删除尾部下标，保证窗口的头部为最大值
            while(!window.empty()&&nums[i]>nums[window.back()])
                window.pop_back();
            window.push_back(i);//此时窗口的头部为最大值
        }
        
        //将第一个窗口的最大值添加到result中
        result.push_back(nums[window.front()]);
        
        for(int i=k;i<nums.size();++i)
        {
            //窗口中的队头下标小于等于i-k表示队头下标属于上一个窗口的，需要删除
            if(!window.empty()&&window.front()<=i-k)
                window.pop_front();
            
            //窗口不为空并且下标i表示的元素大于window尾部下标表示的元素，删除尾部下标，保证窗口的头部为最大值
            while(!window.empty()&&nums[i]>nums[window.back()])
                window.pop_back();
            
            window.push_back(i);//此时窗口的头部为最大值
            result.push_back(nums[window.front()]);//将窗口的最大值添加到result中
        }
        
        return result;
    }
```

- 424 替换后的最长重复字符

本题字符表来表示窗口，窗口的大小与最多字符个数之间的差值表示可以替换的字符个数，当可以替换的字符个数大于k时，我们需要缩小窗口，也就是left右移，直到可以替换的字符个数等于k时，我们可以得到结果

```c++
int characterReplacement(string s, int k) {
        int count[26]={0};//建立字符->字符数量的映射
        
        int left=0,right=0,result=0,maxCount=0;
        
        while(right<s.size())
        {
            count[s[right]-'A']++;
            maxCount=max(maxCount,count[s[right]-'A']);//获得窗口中数量最多的字符数量
            while(right-left+1-maxCount>k){//需要替换的字符就是当前窗口的大小减去窗口中数量最多的字符的数量
                count[s[left]-'A']--;//缩小窗口
                left++;
            }
            //当窗口内可替换的字符数小于等于k时，我们需要根据该窗口长度来确定是否更新result
            result=max(result,right-left+1);
            right++;
        }
        
        return result;
    }
```

-  [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)：本题求的是模式串p在总串s中的所有字母异位词，所以我们所建立的窗口windows大小维持在与模式串p生成的字符表needs的大小相等即可

```c++
 vector<int> findAnagrams(string s, string p) {
        if(s.size()<p.size())return {};//总串比模式串小，直接返回空
        
        int left=0,right=0;
        //ss用来表示窗口windows，pp用来表示needs
        //由于本题求的是字符串中的异位词，所以只需保证windows的大小为needs的大小即可
        vector<int> ss(26,0),pp(26,0),result;
        
        for(int i=0;i<p.size();++i)//生成needs
        {
            pp[p[i]-'a']++;
            ss[s[right++]-'a']++;
        }
        
        //s的前p.size()的字符串刚好与p是异位词
        if(ss==pp)result.push_back(left);
        
        //固定滑动窗口的大小
        while(right<s.size()){
            //窗口右移
            ss[s[right++]-'a']++;  //窗口右边界右移
            ss[s[left++]-'a']--;   //窗口左边界右移
            if(ss==pp)result.push_back(left);
        }
        return result;
    }
```

